#JVM知识点
##1、JVM内存参数设置
*-XX:MaxMetaspaceSize：* 设置原空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小  
*-XX:MetaspaceSize:* 指定元空间出发GC的初始阈值（元空间无固定初始大小），以字节为单位，默认是21M，达到该值就会出发fullGC，进行类型卸载，同事收集器会对该值进行调整，如果释放了大量的空间，就是当降低该值，如果释放了很少的空间，那么在不超过-XX:MaxMetaspaceSize的情况下，适当提高该值，这个跟早起JDK版本的-XX:PermSize参数意思不一样  
*XX:PermSize:* 代表永久代的初始容量  
由于调整元空间大小需要fullGC，这是非常昂贵的操作，如果应用在启动的时候大量FullGC，通常是由于永久代或者元空间发生了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置一样的值，并设置的比初始值大，一般8G的物理内存的机器都是设置为256M  
##2、类加载
####1、类加载检查  
虚拟机遇到一条new指令的时候，首先去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载，解析和初始化过，如果没有，那么必须执行相应的类加载过程  
####2、分配内存  
在类加载检查通过后，接下来虚拟机将为新生对象分配内存，对象所需内存的大小在类加载完之后便可以完全确定，为对象分配空间的任务相同于一块确定大小的内存在Java堆中划分出来  
这个步骤有两个问题：1、如何划分内存  2、在并发情况下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同事使用了原来的指针来分配内存的情况  
####划分内存的方法
####解决并发问题  
使用CAS的方法保证每次操作都是原子操作
#### 3、初始化  
内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值，如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行，这一步操作保证了对象的实例字段在JAVA代码中可以不赋初始值可以直接使用  
#### 4、设置对象头  
初始化零值之后，虚拟机要对对象进行赋值，例如这个对象是哪个类的实例，如果才能找到类的类源数据信息，对象的哈希吗、对象的GC分代年龄、这些东西都放置在对象头ObjectHeader中  
对象在内存中的存储布局可以分为3块区域：对象头、实例数据、对其填充位，HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身运行的数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等、对象的另一部分是类型指针，即对象指向它的类元数据指针，虚拟机通过指针来确定这个对象是哪个类的实例  
####5、执行<init>方法  
执行<init>方法，即对象按照开发人员的意思进行初始化，对应到语言层面上讲。就是为属性赋值，执行构造方法  
####6、查看对象大小 
引入<dependency>
       <groupId>org.openjdk.jol</groupId>
         <artifactId>jol‐core</artifactId>
           <version>0.9</version>
    </dependency>
###对象在Eden区分配  
大多数情况下，对象在Eden区进行分配，当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinitorGC  
*Eden与Survivor默认大小8:1:1*  
大量的对象被分配在Eden区，Eden区满了之后会出发miniorGC，可能会有99%的对象会被当成垃圾回收掉，剩余存货的对象会被挪到为空的那块survivor区，下一次Eden区满了又会触发miniorGC，把Eden区和survivor区垃圾对象回收，把剩余存货的对象一次性挪到为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以比例是8:1:1，一般配置都是Eden尽量大。survivor够用即可  
###大对象直接进入老年代  
大对象就是需要大量连续空间存储的对象，比如字符串、数组。  JVM参数-XX:PretenureSizeThreshold可以设置大对象的大小，如果对象超过设置的大小，这个对象不会进入年轻代，这个参数只在Serial和ParNew两个收集器下有小  
*为什么要这样呢？* 这样是为了避免大对象分配内存是的赋值操作而降低效率  
###长期存活的对象进入老年代  
既然虚拟机采用了分代收集的思想管理内存，那么内存回收是就必须能够识别哪些对象应该放在新生代，哪些对象应该放在老年代，为了做到这一点，虚拟机给每一个对象记录一个对象年龄的计数器  
### 对象动态年龄判断机制  
当前放对象的Survivor区域中，一批对象的总大小大于这块survivor的50%，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了  
例如survivor区域中有一批对象，年龄1+年龄2—+年龄n的多个年龄综合超过survivor区域的50%，此时就会把年龄n都放入老年代，这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代，对象动态年龄判断机制一般是在minor gc之后触发的。  
###老年代空间分配担保机制
年轻代每次minorGC之前JVM都会计算下老年代剩余可用空间  
如果这个可用空间小于年轻力现有的所有对象之和，包括垃圾对象，就会在miniorGC之前进行一次FullGC  
#垃圾手机算法
***
**垃圾手机算法**: 分代收集理论、复制算法、标记整理算法、标记清除算法  
**分代手机理论**: 现在虚拟机的垃圾收集都采用分代收集算法，这种算法没什么新的思想，都是根据对象的存活周期的不同将内存划分为几块，一般JAVA堆分为新生代和老年代，然后针对不同的年龄代采用不同的垃圾收集算法  
新生代：每次收集对象都会有大量的对象变成垃圾，所以在新生代选择复制算法，这样的好处在于，只需要复制很少的存活的对象就能够完成垃圾收集，而在老年代，处于存活状态的对象比较多，如果采用复制算法，需要进行大量的存活对象的复制，这样代价比较高，所以在老年代不适合使用复制算法。还有一点，采用复制算法的话，一般会将内存划分为两个一样大小的内存，其中一块用于存放创建对象的，另外一块用于在进行垃圾收集时，将另外一块存货对象复制完成之后，存放存活对象。这样的话有一个弊端就是空间利用率比较低。  
标记清除的两个弊端：1、效率问题，如果需要标记的对象太对，效率不高。2、空间碎片化，标记清除后会产生大量的不连续碎片  
###垃圾收集器  
JDK8垃圾收集器：年轻代：Serial、ParNew、Parallel。老年代：CMS、Serial Old、Parallel Old。未来可能用到：Epsilon、G1、ZGC、Shenandoah  
垃圾收集器与垃圾收集算法的关系：垃圾收集器是一个类，他们算是垃圾收集算法的实现  
Serial(-XX:+UseSerialGC -XX:+UseSerialOldGC):收集器、是最基本的垃圾收集器，单线程收集、在进行垃圾收集时必须Stop The World，直到垃圾收集结束。 优点：简单高效、收集效率较高。  
Serial Old:Serial收集器的老年代版本，单线程收集，主要是配合Serial使用，还有就是在CMS垃圾收集器在并发清理阶段失效，就会降级使用此垃圾收集器。  
Parallel Scvenge：此收集器基本上就是Serial收集器的多线程版本，除此之外，还有控制参数、收集算法、回收策略等等，默认的收集线程数与当前CPU核数相同，可以使用-XX:ParallelGCThreads指定，但是一般不推荐修改。此垃圾收集器的关注点是吞吐量，高效率的利用CPU，而CMS垃圾收集器更注重用户体验  
Parallel Old:收集器是Parallel Scavenge收集器的老年代版本。使用多线程和标记-整理算法，在注意吞吐量以及资源的场合，都可以优先考虑。Parallel Scavenge收集器和Parallel Old收集器是JDK8新生代和老年代的默认收集器  
CMS:一种以获取最短回收停顿时间为目标的垃圾收集器。非常符合注重用户体验的应用。是HotSpot虚拟机第一款真正意义上的并发收集器，实现了让垃圾收集线程和用户线程同时工作。使用标记-清除算法。分为以下四步  
**初始标记**:暂停所有的用户线程（STW），记录下gc.root能够直接引用的对象，速度很快  
**并发标记**:并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，过程很长，但是可以让用户线程和标记线程同时运行。但是此阶段有可能标记过的对象状态变化产生浮动垃圾。  
**重新标记**:为了修正在并发标记阶段因为用户程序运行而状态发生变化的对象。这个阶段会停止用户线程（STW），而且会比初始标记时间稍微长一些，但是也会比并发标记时间短很多，主要用到三色算法里面的增量更新算法做重新标记。  
**并发清理**:开启用户线程同时GC线程开始对未被标记的对象进行清理，这个阶段如果有新增对象就会被标记为黑色不做任何处理。  
**并发重置**:重置本次GC过程中的标记数据  
**CMS相关核心参数**:1.-XX:+UseConcMarkSweepGC:启动CMS 2.-XX:ConcGCThreads:并发的GC线程数 3.-XX:+UseCMSCompactAtFullCollection:GC之后做内存压缩整理(减少内存碎片化) 4.-XX:CMSFullGCsBeforeCompaction:多少次FullGC之后压缩一次，默认是0，代表每次GC之后都会压缩一次 5.-XX:CMSSinitiatingOccupancyFraction:当老年代内部才能使用达到比例时会出发FullGC，默认是百分之92 6.-XX:+UseCMSInitiatingOccupancyOnly:只是用设定的回收阈值(-XX:CMSSinitiatingOccupancyFraction)，如果不指定JVM只在第一次使用设定值，后续会自动调整 7.-XX:CMSScavengeBeforeRemark:在CMS GC前启动一次migor GC，目的在于减少老年代对于年轻代的引用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时百分之八十都在标记阶段 8.-XX:CMSParallellnitialMarkEnabled:表示在初始标记的时候多线程执行，缩短STW 9.-XX:CMSParallelRemarkEnabled:在重新标记的时候多线程执行，缩短STW  
CMS处理漏标:写屏障 + 增量更新


